<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>draw_stars</title>
</head>
<body>
    <h1>星を描く</h1>

    <canvas id="my-canvas" width="300" height="300"></canvas>

    <script>
        let canvas = document.getElementById('my-canvas');
        let width = canvas.width, height = canvas.height; // キャンバスのサイズ
        let ctx = canvas.getContext('2d', { alpha: false }); // 描画に使うコンテキスト
        let anime = null; // アニメーション
        let time = (new Date()).getTime(); // 時刻(ミリ秒単位)
        let objects = []; // オブジェクトの配列

        /**
         * @typedef {object} Position
         * @property {number} x - X座標
         * @property {number} y - Y座標
         */

        /**
         * @typedef {object} Velocity
         * @property {number} x - X方向の速度
         * @property {number} y - Y方向の速度
         */

        /**
         * @typedef {object} MovingObject
         * @property {Position} position - 初期位置
         * @property {Velocity} velocity - 初期速度
         */

        /**
         * オブジェクト群を作成する。
         * * @global {number} width - 描画領域の幅（初期位置と速度の範囲設定に使用）。
         * @global {number} height - 描画領域の高さ（初期位置と速度の範囲設定に使用）。
         */
        const createObjects = () => {
            let objects = [];
            let cxy = (width + height) / 2;
            // ランダムに位置と速度を決めて、オブジェクトを追加する
            for (let i = 0; i < 4; ++i) {
                // 位置
                const px = Math.random() * width;
                const py = Math.random() * height;
                // 速度
                const vx = (0.5 - Math.random()) * width;
                const vy = (0.5 - Math.random()) * height;
                // 内径
                const outerRadius = (1 + Math.random()) * cxy * 0.1;
                // オブジェクトを追加
                const obj = {position: {x: px, y: py}, velocity: {x: vx, y: vy}, outerRadius: outerRadius};
                objects.push(obj);
            }
            return objects;
        };

        /**
         * オブジェクト群を現在の速度と経過時間に基づいて動かし、
         * 境界 (0, 0) から (width, height) までの範囲で壁との衝突判定と反射を行う。
         * * @param {MovingObject[]} objects - 動かす対象のオブジェクトの配列。各オブジェクトはpositionとvelocityプロパティを持つ。
         * @param {number} diff_time - 前回の更新からの経過時間 (ミリ秒)。
         * @param {number} width - 描画領域の幅 (グローバル変数として定義されていると想定)。
         * @param {number} height - 描画領域の高さ (グローバル変数として定義されていると想定)。
         */
        const moveObjects = (objects, diff_time) => {
            let diff_seconds = diff_time / 1000.0; // ミリ秒を秒単位にする

            for (let obj of objects) {
                obj.position.x += obj.velocity.x * diff_seconds;
                obj.position.y += obj.velocity.y * diff_seconds;
            }

            // カベに当たったら跳ね返る
            for (let obj of objects) {
                if (obj.position.x < 0) {
                    obj.position.x = 0;
                    obj.velocity.x = -obj.velocity.x;
                } else if (obj.position.x > width) {
                    obj.position.x = width;
                    obj.velocity.x = -obj.velocity.x;
                }
                if (obj.position.y < 0) {
                    obj.position.y = 0;
                    obj.velocity.y = -obj.velocity.y;
                } else if (obj.position.y > height) {
                    obj.position.y = height;
                    obj.velocity.y = -obj.velocity.y;
                }
            }
        };

        /**
         * Canvasに指定したパラメータで星を描画します。
         * * @param {CanvasRenderingContext2D} ctx - 描画コンテキスト
         * @param {number} x - 星の中心のX座標
         * @param {number} y - 星の中心のY座標
         * @param {number} outerRadius - 星の角までの半径（外径）
         * @param {number} [innerRadius=outerRadius/2] - 角と角の間のくぼみまでの半径（内径）
         * @param {number} [spikes=5] - 星の角の数
         * @param {number} [rotation=Math.PI*1.5] - 回転角度
         */
        const drawStar = (ctx, x, y, outerRadius, innerRadius = outerRadius / 2, spikes = 5, rotation = Math.PI * 1.5) => {
            const step = Math.PI / spikes;    // 頂点とくぼみの角度の間隔 (1/2角)
            let first = true; // 最初の描画か？
            for (let i = 0; i < spikes; i++) {
                // 1. 頂点の計算 (外径)
                let x0 = x + outerRadius * Math.cos(rotation);
                let y0 = y + outerRadius * Math.sin(rotation);
                if (first) {
                    first = false;
                    ctx.moveTo(x0, y0);
                } else {
                    ctx.lineTo(x0, y0);
                }
                rotation += step; // 次のくぼみへ向けて回転
                // 2. くぼみの計算 (内径)
                let x1 = x + innerRadius * Math.cos(rotation);
                let y1 = y + innerRadius * Math.sin(rotation);
                ctx.lineTo(x1, y1);
                rotation += step; // 次の頂点へ向けて回転
            }
        };

        /**
         * オブジェクトの配列を受け取り、それらを線で結び、各位置にオブジェクトを描画する。
         * * @param {CanvasRenderingContext2D} ctx - 描画に使用するCanvas 2Dコンテキスト（グローバルに定義されていると想定）。
         * @param {MovingObject[]} objects - 描画するオブジェクトの配列。各オブジェクトはpositionプロパティを持つ。
         */
        const drawObjects = (ctx, objects) => {
            // 複数の星を描画する
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.fillStyle = "gold";
            for (let obj of objects) {
                ctx.beginPath();
                drawStar(ctx, obj.position.x, obj.position.y, obj.outerRadius, obj.outerRadius/2, 5);
                ctx.stroke();
                ctx.fill();
            }
        }

        // 描画する関数
        const render = () => {
            width = canvas.width;
            height = canvas.height;

            // 背景を黒で塗りつぶす
            ctx.clearRect(0, 0, width, height);

            // 経過時間を計算
            const new_time = (new Date()).getTime();
            const diff_time = new_time - time; // 経過時間
            time = new_time; // 時刻を更新

            // オブジェクト群を動かす
            moveObjects(objects, diff_time);

            // オブジェクト群を描く
            drawObjects(ctx, objects);

            // 次のアニメーションフレームを要求する
            if (anime)
                anime = window.requestAnimationFrame(render);
        };

        // オブジェクト配列の作成
        objects = createObjects();
        // アニメーションを開始する
        anime = window.requestAnimationFrame(render);
    </script>
</body>
</html>